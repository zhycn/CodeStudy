---
title: JVM 垃圾回收（GC）机制详解与最佳实践
description: 这篇文章详细介绍了JVM垃圾回收（GC）机制的核心概念、工作原理、算法和收集器。通过学习，你将能够理解GC的工作原理，掌握其在实际开发中的应用，避免常见的问题。
author: zhycn
---

# JVM 垃圾回收（GC）机制详解与最佳实践

## 1 垃圾回收概述与核心概念

Java 虚拟机（JVM）的垃圾回收（Garbage Collection，GC）机制是 Java 语言**自动化内存管理**的核心组成部分。它通过自动识别和回收不再使用的对象，释放其占用的内存空间，从而有效防止内存泄漏和内存溢出等问题，让开发者能从繁琐的手动内存管理中解脱出来，专注于业务逻辑实现。

GC 机制需要解决三个基本问题：

- **哪些内存需要回收？** - 通过可达性分析算法判断对象存活性
- **什么时候回收？** - 在内存不足或达到特定阈值时触发回收
- **如何回收？** - 采用不同的算法和收集器策略进行回收

### 1.1 需要回收的内存区域

GC 主要管理以下内存区域：

- **堆内存 (Heap)**：这是 GC 管理的主要区域，存放对象实例和数组。所有线程共享堆内存。
- **方法区 (Metaspace)**：存储类信息、常量、静态变量等数据。JDK 8 开始使用元空间替代永久代。

其他内存区域如虚拟机栈、本地方法栈和程序计数器由线程私有，随线程而生灭，不需要 GC 管理。

## 2 JVM 内存结构：GC 的运作舞台

理解 GC 机制首先需要了解 JVM 的内存布局，尤其是堆内存的结构划分，这直接决定了 GC 的行为和效率。

### 2.1 堆内存分代模型

Java 堆是 GC 管理的主要区域，按对象生命周期划分为以下几个部分：

- **年轻代 (Young Generation)**：存放新创建的、生命周期短的对象。其内部又分为：
  - **Eden区**：新对象最初分配在此区域
  - **Survivor区**：分为S0和S1两个等大的区域，用于对象在晋升前的多次存活

- **老年代 (Old Generation)**：存放从年轻代晋升上来的长寿对象，以及大对象（超过特定阈值的对象）。老年代的特点是内存大、GC 频率低，但每次 GC 的成本高。

- **元空间 (Metaspace)**：从JDK 8 起替代了永久代（PermGen），存放类元数据（Class对象、方法表等）。元空间使用本地内存，避免了永久代的大小限制和 Full GC 问题。

### 2.2 内存分配与对象晋升流程

对象在 JVM 中的生命周期遵循以下典型路径：

1. **对象优先在 Eden 区分配**：绝大多数新创建的对象首先被分配在 Eden 区
2. **Eden 区满时触发 Minor GC**：当 Eden 区空间不足时，会触发一次 Minor GC
3. **存活对象进入 Survivor 区**：Minor GC 后存活的对象被移动到 Survivor 区（通常是 S0）
4. **对象年龄增加**：对象每在 Young Generation 中经历一次 GC 且存活，其年龄计数器就增加 1
5. **对象年龄超过阈值**：当对象年龄达到阈值（默认15，可通过`-XX:MaxTenuringThreshold`调整）或 Survivor 区空间不足时，对象会被晋升到老年代
6. **大对象直接进入老年代**：超过特定大小（可通过`-XX:PretenureSizeThreshold`设置）的对象会直接分配在老年代
7. **老年代空间不足**：当老年代空间不足时，会触发一次 Full GC

## 3 垃圾判定算法：识别可回收对象

JVM 需要准确判断哪些对象是 "垃圾"（即不再使用的对象），这是 GC 的前提。主流 JVM 使用可达性分析算法，而引用计数法因固有缺陷已被淘汰。

### 3.1 引用计数法（已淘汰）

引用计数法为每个对象维护一个引用计数器：

- 当有一个引用指向对象时，计数器+1
- 当引用失效时，计数器-1
- 当计数器为0时，对象被视为可回收

**致命缺陷**：无法解决**循环引用**问题。例如：

```java
class Node {
    Node next;
}

// 创建循环引用
Node node1 = new Node();
Node node2 = new Node();
node1.next = node2;
node2.next = node1;

// 即使外部引用置null，内部仍互相引用，计数器不为0
node1 = null;
node2 = null;
```

这种情况下，即使这两个对象实际上已不可达，引用计数法仍无法回收它们，导致内存泄漏。

### 3.2 可达性分析算法（主流实现）

可达性分析是主流 JVM 采用的垃圾判定算法。其基本原理是：

- 从一组称为"**GC Roots**"的对象作为起始点
- 向下搜索引用链，遍历对象图
- 所有能被 GC Roots 引用链到达的对象是**可达对象**，视为存活
- 所有不能通过任何引用链连接到 GC Roots 的对象是**不可达对象**，标记为垃圾

**GC Roots 对象包括**：

- **虚拟机栈中引用的对象**（如方法参数、局部变量）
- **方法区中静态属性引用的对象**
- **方法区中常量引用的对象**
- **本地方法栈中 JNI 引用的对象**
- **Java 虚拟机内部的引用**（如基本类型对应的 Class 对象）
- **被同步锁持有的对象**

## 4 垃圾回收算法：核心回收策略

垃圾回收算法是 GC 机制的核心，不同算法适用于不同场景和内存区域。以下是三种基础算法及其变体。

### 4.1 标记-清除算法 (Mark-Sweep)

标记-清除算法是最基础的垃圾回收算法，分为两个阶段：

1. **标记阶段**：遍历所有从 GC Roots 可达的对象，并进行标记
2. **清除阶段**：遍历堆内存，回收所有未被标记的对象占用的空间

**优点**：

- 实现相对简单
- 不需要移动对象，减少了开销

**缺点**：

- **内存碎片化**：清除后会产生大量不连续的内存碎片，可能导致后续大对象分配失败
- **效率问题**：标记和清除两个过程的效率都不高，需要两次遍历

### 4.2 复制算法 (Copying)

复制算法将可用内存按容量划分为大小相等的两块，每次只使用其中一块：

1. 当使用的这块内存用尽时，将存活的对象复制到另一块内存
2. 一次性清理已使用的那块内存

**优点**：

- 实现简单，运行高效
- 避免了内存碎片问题

**缺点**：

- 内存利用率低，只能使用一半的内存空间
- 对象移动需要修改引用，增加了开销

**应用场景**：主要适用于**新生代**，因为新生代中98%的对象都是"朝生夕死"的，存活对象少，复制成本低。

### 4.3 标记-整理算法 (Mark-Compact)

标记-整理算法结合了标记-清除和复制算法的优点：

1. **标记阶段**：与标记-清除算法相同，标记所有可达对象
2. **整理阶段**：将所有存活对象向内存一端移动，然后清理边界以外的内存

**优点**：

- 避免了内存碎片问题
- 不需要预留一半空间，内存利用率高

**缺点**：

- 移动对象需要额外开销，效率较低
- 需要"Stop The World"，暂停用户线程

**应用场景**：主要适用于**老年代**，因为老年代中对象存活率高，不适合复制算法。

### 4.4 分代收集算法 (Generational Collection)

现代 JVM 普遍采用分代收集算法，根据对象存活周期的不同将内存划分为几代，每代采用不同的垃圾回收算法：

- **新生代**：使用复制算法（如 Eden 区和两个 Survivor 区的配合）
- **老年代**：使用标记-清除或标记-整理算法

这种设计的理论基础是**弱代假说**（Weak Generational Hypothesis）：

1. 绝大多数对象都是朝生夕死的
2. 熬过越多次垃圾收集过程的对象就越难以消亡

分代收集使JVM能够针对不同特性的内存区域采用最合适的回收策略，平衡回收效率和内存利用率。

## 5 垃圾收集器：算法的具体实现

垃圾收集器是垃圾回收算法的具体实现。JVM提供了多种收集器，适应不同的应用场景和需求。

### 5.1 串行收集器 (Serial Collector)

串行收集器是最基本、最古老的收集器，使用**单线程**进行垃圾回收工作：

- **新生代**：使用复制算法
- **老年代**：使用标记-整理算法

**特点**：在进行垃圾回收时，必须暂停所有用户线程（Stop-The-World）

**适用场景**：客户端模式、小型应用、单核处理器或低内存环境

**启用参数**：`-XX:+UseSerialGC`

### 5.2 并行收集器 (Parallel Collector)

并行收集器是 JVM 的**默认收集器**（在JDK 8 及之前），使用多线程进行垃圾回收：

- **新生代**：使用复制算法，多线程并行
- **老年代**：使用标记-整理算法，多线程并行

**特点**：注重**吞吐量**（Throughput），即最大化应用程序的执行时间占比

**适用场景**：后台计算、数据处理等对吞吐量要求高、对响应时间不敏感的应用

**启用参数**：`-XX:+UseParallelGC`（新生代）和`-XX:+UseParallelOldGC`（老年代）

### 5.3 CMS 收集器 (Concurrent Mark-Sweep)

CMS收集器是以获取**最短回收停顿时间**为目标的收集器，适用于对响应时间敏感的应用：

**工作流程分为四个阶段**：

1. **初始标记**（Initial Mark）：标记 GC Roots 直接关联的对象，需要 STW 但速度很快
2. **并发标记**（Concurrent Mark）：GC 线程与用户线程并发执行，遍历对象图进行标记
3. **重新标记**（Remark）：修正并发标记期间因用户程序运行而变动的标记，需要 STW
4. **并发清除**（Concurrent Sweep）：清除垃圾对象，与用户线程并发执行

**优点**：并发收集，低停顿时间

**缺点**：

- 对 CPU 资源敏感，并发阶段会占用一部分线程导致应用变慢
- 无法处理"浮动垃圾"，可能在并发清理阶段产生新的垃圾
- 使用标记-清除算法，会产生内存碎片

**适用场景**：Web 服务器、互联网应用等对响应时间要求高的场景

**启用参数**：`-XX:+UseConcMarkSweepGC`

### 5.4 G1 收集器 (Garbage-First)

G1 收集器是 JDK 7 update 4 引入的面向服务端应用的垃圾收集器，JDK 9 及之后成为默认收集器。

**核心特性**：

- **分区模型**：将堆内存划分为多个大小相等的 Region（默认2048个）
- **预测停顿时间**：可以通过`-XX:MaxGCPauseMillis`参数设置期望的最大停顿时间
- **优先级回收**：优先回收垃圾最多的区域（Garbage-First名称的由来）

**工作流程**：

1. **初始标记**（Initial Mark）：标记 GC Roots 直接关联的对象，需要 STW
2. **并发标记**（Concurrent Mark）：与用户线程并发执行，遍历对象图
3. **最终标记**（Final Mark）：处理并发标记期间遗留的少量变更，需要 STW
4. **筛选回收**（Live Data Counting and Evacuation）：根据 Region 的回收价值和成本排序，选择收益最高的 Region 进行回收

**适用场景**：大内存（6GB 以上）、多核 CPU 的服务端应用，要求低停顿且高吞吐的场景

**启用参数**：`-XX:+UseG1GC`

### 5.5 ZGC 收集器 (Z Garbage Collector)

ZGC是 JDK 11 引入的实验性低延迟收集器，JDK 15 成为正式特性。

**核心目标**：

- 停顿时间不超过10ms
- 支持 TB 级堆内存
- 停顿时间不随堆大小增加而增加

**关键技术**：

- **染色指针**（Colored Pointers）：将元数据信息存储在指针中而非对象头中
- **读屏障**（Load Barrier）：在访问对象时执行一些额外的检查操作
- **写屏障**（Store Barrier）：在写入对象时执行一些额外的检查操作
- **并发压缩**（Concurrent Compaction）：在后台线程中压缩存活对象，减少内存碎片
- **并发标记**（Concurrent Mark）：与用户线程并发执行，遍历对象图

**适用场景**：超大堆内存、极低延迟要求的应用，如大数据平台、内存数据库

**启用参数**：`-XX:+UseZGC`

### 5.6 垃圾收集器比较与选择

下表总结了主流垃圾收集器的特点和适用场景：

| **收集器**     | **算法**        | **特点**            | **适用场景**       | **JDK版本**  |
| -------------- | --------------- | ------------------- | ------------------ | ------------ |
| **Serial**     | 复制+标记整理   | 单线程，STW 时间长  | 客户端、小内存     | 所有版本     |
| **Parallel**   | 复制+标记整理   | 多线程，高吞吐量    | 后台计算、批处理   | 所有版本     |
| **CMS**        | 标记清除        | 并发收集，低停顿    | Web 应用、响应敏感 | JDK 8 及之前 |
| **G1**         | 标记整理+复制   | 分区回收，可控停顿  | 大内存服务端应用   | JDK 7+       |
| **ZGC**        | 染色指针+读屏障 | 超低停顿，TB 堆支持 | 极低延迟应用       | JDK 11+      |
| **Shenandoah** | 连接矩阵+读屏障 | 低停顿，并发压缩    | 低延迟应用         | OpenJDK      |

**选择策略**：

- **吞吐量优先**：Parallel Scavenge + Parallel Old
- **响应时间优先**：CMS（JDK 8 及之前）或 G1（JDK 7+）或 ZGC/Shenandoah（JDK 11+）
- **小内存应用**：Serial 收集器
- **大内存低延迟**：G1、ZGC 或 Shenandoah

## 6 垃圾收集器性能优化与最佳实践

GC 调优是 Java 性能优化的重要组成部分，合理配置可以显著提高应用性能和稳定性。

### 6.1 基础内存参数配置

**堆内存大小设置**：

```bash
# 初始堆大小和最大堆大小设置为相同值，避免动态调整开销
-Xms4g -Xmx4g

# 新生代大小设置（堆的1/4到1/3之间）
-Xmn2g
# 或使用比例设置新生代大小
-XX:NewRatio=3  # 老年代:新生代=3:1
```

**Survivor区比例调整**：

```bash
# 调整Eden与Survivor区的比例（默认8表示Eden:Survivor=8:1:1）
-XX:SurvivorRatio=6  # Eden占6/8，每个Survivor占1/8
```

**元空间设置**：

```bash
# 设置元空间初始大小和最大大小
-XX:MetaspaceSize=256m
-XX:MaxMetaspaceSize=512m
```

### 6.2 GC 策略参数配置

**G1收集器调优**：

```bash
# 启用G1收集器
-XX:+UseG1GC

# 设置最大停顿时间目标（默认200ms）
-XX:MaxGCPauseMillis=100

# 设置并行GC线程数（通常设置为CPU核心数）
-XX:ParallelGCThreads=8

# 设置并发GC线程数（通常为并行线程数的1/4）
-XX:ConcGCThreads=2
```

**对象晋升调优**：

```bash
# 设置对象晋升老年代的年龄阈值（默认15）
-XX:MaxTenuringThreshold=10

# 设置大对象直接进入老年代的阈值
-XX:PretenureSizeThreshold=1048576  # 1MB

# 设置直接内存大小
-XX:MaxDirectMemorySize=1g
```

### 6.3 GC日志与监控

**开启GC日志**：

```bash
# 开启详细GC日志记录
-XX:+PrintGCDetails
-XX:+PrintGCTimeStamps
-XX:+PrintHeapAtGC
-XX:+PrintTenuringDistribution

# 输出GC日志到文件并配置滚动策略
-Xloggc:/var/log/gc.log
-XX:+UseGCLogFileRotation
-XX:NumberOfGCLogFiles=5
-XX:GCLogFileSize=20M
```

**OOM 时自动转储堆内存**：

```bash
# 在发生OOM时自动生成堆转储文件
-XX:+HeapDumpOnOutOfMemoryError
-XX:HeapDumpPath=/var/log/heapdump.hprof
```

### 6.4 常见问题与解决方案

**问题1：频繁 Full GC**

**原因分析**：

- 老年代空间不足
- 大对象直接分配在老年代
- 对象晋升过早或过多

**解决方案**：

- 增加堆大小或老年代比例
- 调整`-XX:PretenureSizeThreshold`避免大对象直接进入老年代
- 调整`-XX:MaxTenuringThreshold`优化对象晋升年龄
- 使用 G1 收集器并调整`-XX:InitiatingHeapOccupancyPercent`（默认45%）

**问题2：长时间 GC 停顿**

**原因分析**：

- 堆内存过大，导致 GC 时间延长
- 存活对象过多，标记和复制耗时

**解决方案**：

- 使用低延迟收集器（G1、ZGC、Shenandoah）
- 减小堆大小或调整区域大小（如 G1 的`-XX:G1HeapRegionSize`）
- 优化应用代码，减少内存分配和对象存活时间

**问题3：内存碎片**

**原因分析**：

- 使用标记-清除算法（如 CMS）导致内存碎片
- 长时间运行后老年代空间碎片化

**解决方案**：

- 对于 CMS，启用压缩：`-XX:+UseCMSCompactAtFullCollection`和`-XX:CMSFullGCsBeforeCompaction=0`
- 使用 G1、ZGC 等自动整理碎片的收集器

### 6.5 实战调优案例

**案例1：高并发Web应用（响应敏感）**

```bash
java -Xms8g -Xmx8g -Xmn4g \
     -XX:+UseG1GC -XX:MaxGCPauseMillis=150 \
     -XX:ParallelGCThreads=12 -XX:ConcGCThreads=4 \
     -XX:InitiatingHeapOccupancyPercent=35 \
     -XX:+HeapDumpOnOutOfMemoryError \
     -jar your-app.jar
```

**案例2：批处理应用（吞吐量优先）**

```bash
java -Xms16g -Xmx16g \
     -XX:+UseParallelGC -XX:+UseParallelOldGC \
     -XX:ParallelGCThreads=16 \
     -XX:GCTimeRatio=99 \
     -jar batch-job.jar
```

**案例3：低延迟交易系统**

```bash
java -Xms32g -Xmx32g \
     -XX:+UseZGC -XX:ConcGCThreads=8 \
     -XX:ZCollectionInterval=5 \
     -jar trading-system.jar
```

## 7 总结与展望

JVM 垃圾回收机制经过多年发展，已经从简单的单线程收集器演进到复杂的并发、低延迟收集器。了解 GC 的工作原理和不同收集器的特性，对于构建高性能 Java 应用至关重要。

**未来发展趋势**：

1. **低延迟化**：ZGC、Shenandoah 等收集器将进一步降低停顿时间，满足更极致的延迟要求
2. **大内存优化**：随着内存容量不断增加，GC 算法需要更好地支持 TB 级堆内存，如 G1 收集器的区域化设计
3. **云原生适配**：容器化环境下的 GC 调优，如感知容器内存限制、自适应调整等
4. **AI 辅助调优**：利用机器学习技术自动分析 GC 日志和优化参数配置

**最佳实践总结**：

1. 根据应用特性选择合适的垃圾收集器
2. 合理设置堆大小和各代比例，避免过度调优
3. 持续监控 GC 日志和性能指标，及时发现问题和优化点
4. 结合应用代码优化，减少对象创建和延长生命周期
5. 定期进行压力测试和性能剖析，验证 GC 配置效果

通过深入理解 JVM 垃圾回收机制，开发者可以更好地编写高性能 Java 应用，有效避免内存相关问题，提升系统稳定性和用户体验。
